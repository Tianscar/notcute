package a3wt.android;

import a3wt.graphics.*;
import android.annotation.SuppressLint;
import android.content.ClipData;
import android.content.ClipDescription;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.res.AssetManager;
import android.content.res.Resources;
import android.graphics.*;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.util.DisplayMetrics;
import android.view.InputDevice;
import android.view.MotionEvent;
import android.view.KeyEvent;
import android.view.PointerIcon;
import a3wt.app.A3Clipboard;
import a3wt.input.A3InputListener;
import pl.droidsonroids.gif.GifDrawable;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;

import static a3wt.util.A3Preconditions.checkArgNotEmpty;
import static a3wt.util.A3Preconditions.checkArgNotNull;

public class A3AndroidUtils {

    private A3AndroidUtils(){}

    /**
     * Returns a drawable object associated with a particular resource ID.
     * <p>
     * Starting in {@link Build.VERSION_CODES#LOLLIPOP}, the
     * returned drawable will be styled for the specified Context's theme.
     *
     * @param id The desired resource identifier, as generated by the aapt tool.
     *           This integer encodes the package, type, and resource entry.
     *           The value 0 is an invalid identifier.
     * @return Drawable An object that can be used to draw this resource.
     */
    @SuppressLint("UseCompatLoadingForDrawables")
    public static Drawable getDrawable(final Context context, final int id) {
        checkArgNotNull(context, "context");
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            return context.getDrawable(id);
        } else {
            return context.getResources().getDrawable(id);
        }
    }

    public static Bitmap copyBitmap(final Bitmap source) {
        checkArgNotNull(source, "source");
        return source.copy(source.getConfig(), source.isMutable());
    }

    public static Bitmap copyBitmap(final Bitmap source, final Bitmap.Config config) {
        checkArgNotNull(source, "source");
        return source.copy(config, source.isMutable());
    }

    public static int getDisplayWidth(final Resources resources) {
        checkArgNotNull(resources, "resources");
        final DisplayMetrics metrics = resources.getDisplayMetrics();
        return metrics.widthPixels;
    }

    public static int getDisplayHeight(final Resources resources) {
        checkArgNotNull(resources, "resources");
        final DisplayMetrics metrics = resources.getDisplayMetrics();
        return metrics.heightPixels;
    }

    public static Paint.Join strokeJoin2PaintStrokeJoin(final int join) {
        switch (join) {
            case A3Graphics.Join.MITER:
                return Paint.Join.MITER;
            case A3Graphics.Join.ROUND:
                return Paint.Join.ROUND;
            case A3Graphics.Join.BEVEL:
                return Paint.Join.BEVEL;
            default:
                return null;
        }
    }

    public static Paint.Cap strokeCap2PaintStrokeCap(final int cap) {
        switch (cap) {
            case A3Graphics.Cap.BUTT:
                return Paint.Cap.BUTT;
            case A3Graphics.Cap.ROUND:
                return Paint.Cap.ROUND;
            case A3Graphics.Cap.SQUARE:
                return Paint.Cap.SQUARE;
            default:
                return null;
        }
    }

    public static int paintStrokeJoin2StrokeJoin(final Paint.Join join) {
        switch (join) {
            case MITER:
                return A3Graphics.Join.MITER;
            case ROUND:
                return A3Graphics.Join.ROUND;
            case BEVEL:
                return A3Graphics.Join.BEVEL;
            default:
                return -1;
        }
    }

    public static int paintStrokeCap2StrokeCap(final Paint.Cap cap) {
        switch (cap) {
            case BUTT:
                return A3Graphics.Cap.BUTT;
            case ROUND:
                return A3Graphics.Cap.ROUND;
            case SQUARE:
                return A3Graphics.Cap.SQUARE;
            default:
                return -1;
        }
    }

    public static int typefaceStyle2FontStyle(final int style) {
        switch (style) {
            case Typeface.NORMAL:
                return A3Font.Style.NORMAL;
            case Typeface.BOLD:
                return A3Font.Style.BOLD;
            case Typeface.ITALIC:
                return A3Font.Style.ITALIC;
            case Typeface.BOLD_ITALIC:
                return A3Font.Style.BOLD_ITALIC;
            default:
                return -1;
        }
    }

    public static int fontStyle2TypefaceStyle(final int style) {
        switch (style) {
            case A3Font.Style.NORMAL:
                return Typeface.NORMAL;
            case A3Font.Style.BOLD:
                return Typeface.BOLD;
            case A3Font.Style.ITALIC:
                return Typeface.ITALIC;
            case A3Font.Style.BOLD_ITALIC:
                return Typeface.BOLD_ITALIC;
            default:
                return -1;
        }
    }

    public static Paint.Style style2PaintStyle(final int style) {
        switch (style) {
            case A3Graphics.Style.STROKE:
                return Paint.Style.STROKE;
            case A3Graphics.Style.FILL:
                return Paint.Style.FILL;
            default:
                return null;
        }
    }

    public static int paintStyle2Style(final Paint.Style style) {
        switch (style) {
            case STROKE:
                return A3Graphics.Style.STROKE;
            case FILL:
                return A3Graphics.Style.FILL;
            default:
                return -1;
        }
    }

    public static boolean deleteSharedPreferences(final Context context, final String name) {
        checkArgNotNull(context, "context");
        checkArgNotEmpty(name, "name");
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            return context.deleteSharedPreferences(name);
        } else {
            context.getSharedPreferences(name, Context.MODE_PRIVATE).edit().clear().commit();
            return new File(new File(context.getApplicationInfo().dataDir, "shared_prefs"), name + ".xml").delete();
        }
    }

    public static File getSharedPreferencesDir(final Context context) {
        checkArgNotNull(context, "context");
        return new File(context.getApplicationInfo().dataDir, "shared_prefs");
    }

    public static Typeface readTypeface(final AssetManager assets, final String asset) throws IOException {
        checkArgNotNull(assets, "assets");
        checkArgNotEmpty(asset, "asset");
        final Typeface typeface;
        try {
            typeface = Typeface.createFromAsset(assets, asset);
        }
        catch (RuntimeException e) {
            throw new IOException(e);
        }
        return typeface;
    }

    public static Typeface readTypeface(final File input) throws IOException {
        checkArgNotNull(input, "input");
        final Typeface typeface;
        try {
            typeface = Typeface.createFromFile(input);
        }
        catch (RuntimeException e) {
            throw new IOException(e);
        }
        return typeface;
    }

    public static boolean isExternalStorageWriteable() {
        return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
    }

    public static boolean isExternalStorageReadable() {
        return isExternalStorageWriteable() || Environment.MEDIA_MOUNTED_READ_ONLY.equals(Environment.getExternalStorageState());
    }

    public static File getStorageDir() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            return Environment.getStorageDirectory();
        }
        else {
            return isExternalStorageWriteable() ? Environment.getExternalStorageDirectory() : Environment.getDataDirectory();
        }
    }

    public static int buttonState2Button(final int buttonState) {
        if (buttonState == 0 || (buttonState & MotionEvent.BUTTON_PRIMARY) != 0) return A3InputListener.Button.LEFT;
        else if ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0) return A3InputListener.Button.RIGHT;
        else if ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0) return A3InputListener.Button.MIDDLE;
        else return -1;
    }

    public static int motionEventButton2Button(final int button) {
        switch (button) {
            case MotionEvent.BUTTON_PRIMARY:
                return A3InputListener.Button.LEFT;
            case MotionEvent.BUTTON_SECONDARY:
                return A3InputListener.Button.RIGHT;
            case MotionEvent.BUTTON_TERTIARY:
                return A3InputListener.Button.MIDDLE;
            default:
                return -1;
        }
    }

    public static int button2MotionEventButton(final int button) {
        switch (button) {
            case A3InputListener.Button.LEFT:
                return MotionEvent.BUTTON_PRIMARY;
            case A3InputListener.Button.RIGHT:
                return MotionEvent.BUTTON_SECONDARY;
            case A3InputListener.Button.MIDDLE:
                return MotionEvent.BUTTON_TERTIARY;
            default:
                return -1;
        }
    }

    public static boolean commonOnTouchEvent(final List<A3InputListener> listeners, final MotionEvent event) {
        checkArgNotNull(listeners, "listeners");
        checkArgNotNull(event, "event");
        boolean downResult = false;
        boolean moveResult = false;
        boolean upResult = false;
        final int pointerIndex = event.getPointerCount() - 1;
        final float x = event.getX(pointerIndex);
        final float y = event.getY(pointerIndex);
        final int buttonState = event.getButtonState();
        for (final A3InputListener listener : listeners) {
            switch (event.getActionMasked()) {
                case MotionEvent.ACTION_BUTTON_PRESS:
                case MotionEvent.ACTION_DOWN:
                case MotionEvent.ACTION_POINTER_DOWN:
                    if (!downResult) downResult = listener.pointerDown(x, y, pointerIndex, buttonState2Button(buttonState));
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (!moveResult) moveResult = listener.pointerDragged(x, y, pointerIndex);
                    break;
                case MotionEvent.ACTION_BUTTON_RELEASE:
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_POINTER_UP:
                    if (!upResult) upResult = listener.pointerUp(x, y, pointerIndex, buttonState2Button(buttonState));
                    break;
            }
        }
        return downResult || moveResult || upResult;
    }

    public static boolean commonOnHoverEvent(final List<A3InputListener> listeners, final MotionEvent event) {
        checkArgNotNull(listeners, "listeners");
        checkArgNotNull(event, "event");
        boolean enterResult = false;
        boolean moveResult = false;
        boolean exitResult = false;
        final float x = event.getX();
        final float y = event.getY();
        for (final A3InputListener listener : listeners) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_HOVER_ENTER:
                    if (!enterResult) enterResult = listener.mouseEntered(x, y);
                    break;
                case MotionEvent.ACTION_HOVER_MOVE:
                    if (!moveResult) moveResult = listener.mouseMoved(x, y);
                    break;
                case MotionEvent.ACTION_HOVER_EXIT:
                    if (!exitResult) exitResult = listener.mouseExited(x, y);
                    break;
            }
        }
        return enterResult || moveResult || exitResult;
    }

    public static int getScreenWidth(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().widthPixels;
    }

    public static int getScreenHeight(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().heightPixels;
    }

    public static int getPPI(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().densityDpi;
    }

    public static float getDensity(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().density;
    }

    public static float getScaledDensity(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().scaledDensity;
    }

    public static void putPlainTextToClipboard(final ClipboardManager manager, final CharSequence plainText) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(plainText, "plainText");
        manager.setPrimaryClip(ClipData.newPlainText(null, plainText));
    }

    public static void putPlainTextToClipboard(final Clipboard clipboard, final CharSequence plainText) {
        checkArgNotNull(clipboard, "clipboard");
        checkArgNotNull(plainText, "plainText");
        clipboard.setPrimaryClip(ClipData.newPlainText(null, plainText));
    }

    public static CharSequence getPlainTextFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) return null;
        final StringBuilder builder = new StringBuilder();
        CharSequence text;
        final int itemCount = clipData.getItemCount();
        for (int i = 0; i < itemCount; i ++) {
            text = clipData.getItemAt(i).getText();
            if (text != null) {
                builder.append(text);
                if (i + 1 < itemCount) builder.append('\n');
            }
        }
        return builder;
    }

    public static CharSequence getPlainTextFromClipboard(final Clipboard clipboard) {
        checkArgNotNull(clipboard, "clipboard");
        if (!clipboard.hasPrimaryClip()) return null;
        final ClipData clipData = clipboard.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) return null;
        final StringBuilder builder = new StringBuilder();
        CharSequence text;
        final int itemCount = clipData.getItemCount();
        for (int i = 0; i < itemCount; i ++) {
            text = clipData.getItemAt(i).getText();
            if (text != null) {
                builder.append(text);
                if (i + 1 < itemCount) builder.append('\n');
            }
        }
        return builder;
    }

    public static void putHTMLTextToClipboard(final ClipboardManager manager, final String HTMLText) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(HTMLText, "HTMLText");
        manager.setPrimaryClip(ClipData.newHtmlText(null, HTMLText, HTMLText));
    }

    public static void putHTMLTextToClipboard(final Clipboard clipboard, final String HTMLText) {
        checkArgNotNull(clipboard, "clipboard");
        checkArgNotNull(HTMLText, "HTMLText");
        clipboard.setPrimaryClip(ClipData.newHtmlText(null, HTMLText, HTMLText));
    }

    public static String getHTMLTextFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) return null;
        final StringBuilder builder = new StringBuilder();
        String text;
        final int itemCount = clipData.getItemCount();
        for (int i = 0; i < itemCount; i ++) {
            text = clipData.getItemAt(i).getHtmlText();
            if (text != null) {
                builder.append(text);
                if (i + 1 < itemCount) builder.append('\n');
            }
        }
        return builder.toString();
    }

    public static String getHTMLTextFromClipboard(final Clipboard clipboard) {
        checkArgNotNull(clipboard, "clipboard");
        if (!clipboard.hasPrimaryClip()) return null;
        final ClipData clipData = clipboard.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) return null;
        final StringBuilder builder = new StringBuilder();
        String text;
        final int itemCount = clipData.getItemCount();
        for (int i = 0; i < itemCount; i ++) {
            text = clipData.getItemAt(i).getHtmlText();
            if (text != null) {
                builder.append(text);
                if (i + 1 < itemCount) builder.append('\n');
            }
        }
        return builder.toString();
    }

    public static void putURIsToClipboard(final ClipboardManager manager, final URI[] uris) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(uris, "uris");
        if (uris.length > 0) {
            final ClipData clipData = ClipData.newRawUri(null, Uri.parse(Uri.decode(uris[0].toString())));
            for (int i = 1; i < uris.length; i ++) {
                clipData.addItem(new ClipData.Item(Uri.parse(uris[i].toString())));
            }
            manager.setPrimaryClip(clipData);
        }
        else manager.setPrimaryClip(ClipData.newPlainText(null, ""));
    }

    public static void putURIsToClipboard(final Clipboard clipboard, final URI[] uris) {
        checkArgNotNull(clipboard, "clipboard");
        checkArgNotNull(uris, "uris");
        if (uris.length > 0) {
            final ClipData clipData = ClipData.newRawUri(null, Uri.parse(Uri.decode(uris[0].toString())));
            for (int i = 1; i < uris.length; i ++) {
                clipData.addItem(new ClipData.Item(Uri.parse(uris[i].toString())));
            }
            clipboard.setPrimaryClip(clipData);
        }
        else clipboard.setPrimaryClip(ClipData.newPlainText(null, ""));
    }

    public static URI[] getURIsFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return null;
        final List<URI> uris = new ArrayList<>();
        Uri uri;
        for (int i = 0; i < clipData.getItemCount(); i ++) {
            uri = clipData.getItemAt(i).getUri();
            if (uri != null) uris.add(URI.create(uri.toString()));
        }
        return uris.toArray(new URI[0]);
    }

    public static URI[] getURIsFromClipboard(final Clipboard clipboard) {
        checkArgNotNull(clipboard, "clipboard");
        if (!clipboard.hasPrimaryClip()) return null;
        final ClipData clipData = clipboard.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return null;
        final List<URI> uris = new ArrayList<>();
        Uri uri;
        for (int i = 0; i < clipData.getItemCount(); i ++) {
            uri = clipData.getItemAt(i).getUri();
            if (uri != null) uris.add(URI.create(uri.toString()));
        }
        return uris.toArray(new URI[0]);
    }

    public static void putUrisToClipboard(final ClipboardManager manager, final Uri[] uris) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(uris, "uris");
        if (uris.length > 0) {
            final ClipData clipData = ClipData.newRawUri(null, uris[0]);
            for (int i = 1; i < uris.length; i ++) {
                clipData.addItem(new ClipData.Item(uris[i]));
            }
            manager.setPrimaryClip(clipData);
        }
        else manager.setPrimaryClip(ClipData.newPlainText(null, ""));
    }

    public static void putUrisToClipboard(final Clipboard clipboard, final Uri[] uris) {
        checkArgNotNull(clipboard, "clipboard");
        checkArgNotNull(uris, "uris");
        if (uris.length > 0) {
            final ClipData clipData = ClipData.newRawUri(null, uris[0]);
            for (int i = 1; i < uris.length; i ++) {
                clipData.addItem(new ClipData.Item(uris[i]));
            }
            clipboard.setPrimaryClip(clipData);
        }
        else clipboard.setPrimaryClip(ClipData.newPlainText(null, ""));
    }

    public static Uri[] getUrisFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return null;
        final List<Uri> uris = new ArrayList<>();
        Uri uri;
        for (int i = 0; i < clipData.getItemCount(); i ++) {
            uri = clipData.getItemAt(i).getUri();
            if (uri != null) uris.add(uri);
        }
        return uris.toArray(new Uri[0]);
    }

    public static Uri[] getUrisFromClipboard(final Clipboard clipboard) {
        checkArgNotNull(clipboard, "clipboard");
        if (!clipboard.hasPrimaryClip()) return null;
        final ClipData clipData = clipboard.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return null;
        final List<Uri> uris = new ArrayList<>();
        Uri uri;
        for (int i = 0; i < clipData.getItemCount(); i ++) {
            uri = clipData.getItemAt(i).getUri();
            if (uri != null) uris.add(uri);
        }
        return uris.toArray(new Uri[0]);
    }

    public static int getClipboardContentType(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return -1;
        final ClipData clipData = manager.getPrimaryClip();
        final ClipDescription description = clipData.getDescription();
        if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) return A3Clipboard.ContentType.HTML_TEXT;
        else if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) return A3Clipboard.ContentType.PLAIN_TEXT;
        else if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return A3Clipboard.ContentType.URI_LIST;
        else return -1;
    }

    public static int getClipboardContentType(final Clipboard clipboard) {
        checkArgNotNull(clipboard, "clipboard");
        if (!clipboard.hasPrimaryClip()) return -1;
        final ClipData clipData = clipboard.getPrimaryClip();
        final ClipDescription description = clipData.getDescription();
        if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) return A3Clipboard.ContentType.HTML_TEXT;
        else if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) return A3Clipboard.ContentType.PLAIN_TEXT;
        else if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return A3Clipboard.ContentType.URI_LIST;
        else return -1;
    }

    public static boolean commonOnKeyEvent(final List<A3InputListener> listeners, final KeyEvent event) {
        checkArgNotNull(listeners, "listeners");
        checkArgNotNull(event, "event");
        boolean downResult = false;
        boolean upResult = false;
        final int keyCode = event.getKeyCode();
        for (A3InputListener listener : listeners) {
            switch (event.getAction()) {
                case KeyEvent.ACTION_DOWN:
                    if (!downResult) downResult = listener.keyDown(keyCode, A3InputListener.KeyLocation.STANDARD);
                    break;
                case KeyEvent.ACTION_UP:
                    if (!upResult) upResult = listener.keyUp(keyCode, A3InputListener.KeyLocation.STANDARD);
                    break;
            }
        }
        return downResult || upResult;
    }

    public static boolean commonOnMouseWheelMotion(final List<A3InputListener> listeners, final MotionEvent event) {
        checkArgNotNull(listeners, "listeners");
        checkArgNotNull(event, "event");
        if ((event.getSource() & InputDevice.SOURCE_MOUSE) == 0) return false;
        boolean result = false;
        for (final A3InputListener listener : listeners) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_SCROLL:
                    if (!result) result = listener.mouseWheelScrolled(event.getAxisValue(MotionEvent.AXIS_VSCROLL), A3InputListener.ScrollType.UNIT);
                    break;
            }
        }
        return result;
    }

    public static Bitmap getBitmap(final Bitmap source, final Bitmap.Config config) {
        checkArgNotNull(source, "source");
        if (config == null || source.getConfig().equals(config)) return source;
        else {
            final Bitmap result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), config);
            final Canvas canvas = new Canvas(result);
            canvas.drawBitmap(source, 0, 0, null);
            if (!source.isRecycled()) source.recycle();
            return result;
        }
    }

    public static Bitmap getAlignedBitmap(final Bitmap source, final int alignX, final int alignY, final int width, final int height) {
        checkArgNotNull(source, "source");
        if (source.getWidth() == width && source.getHeight() == height) return source;
        final Bitmap result = Bitmap.createBitmap(width, height, source.getConfig());
        final Canvas canvas = new Canvas(source);
        canvas.drawBitmap(source, alignX, alignY, null);
        if (!source.isRecycled()) source.recycle();
        return result;
    }

    public static A3FramedImage gifDrawable2FramedImage(final GifDrawable drawable, final Bitmap.Config config) {
        checkArgNotNull(drawable, "drawable");
        try {
            A3Image.Frame[] frames = new A3Image.Frame[drawable.getNumberOfFrames()];
            for (int i = 0; i < frames.length; i ++) {
                frames[i] = new A3Image.DefaultFrame(new AndroidA3Image(getBitmap(drawable.seekToFrameAndGet(i), config)), drawable.getFrameDuration(i));
            }
            A3FramedImage result = new DefaultA3FramedImage(frames);
            result.setLooping(drawable.getLoopCount());
            return result;
        }
        finally {
            if (!drawable.isRecycled()) drawable.recycle();
        }
    }

    public static int cursorType2PointerIconType(int type) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            switch (type) {
                case A3Cursor.Type.GONE:
                    return PointerIcon.TYPE_NULL;
                case A3Cursor.Type.ARROW:
                    return PointerIcon.TYPE_ARROW;
                case A3Cursor.Type.CROSSHAIR:
                    return PointerIcon.TYPE_CROSSHAIR;
                case A3Cursor.Type.IBEAM:
                    return PointerIcon.TYPE_TEXT;
                case A3Cursor.Type.WAIT:
                    return PointerIcon.TYPE_WAIT;
                case A3Cursor.Type.RESIZE_NS:

                case A3Cursor.Type.RESIZE_N://FIXME
                case A3Cursor.Type.RESIZE_S://FIXME

                    return PointerIcon.TYPE_VERTICAL_DOUBLE_ARROW;
                case A3Cursor.Type.RESIZE_WE:

                case A3Cursor.Type.RESIZE_W://FIXME
                case A3Cursor.Type.RESIZE_E://FIXME

                    return PointerIcon.TYPE_HORIZONTAL_DOUBLE_ARROW;
                case A3Cursor.Type.RESIZE_NWSE:

                case A3Cursor.Type.RESIZE_NW://FIXME
                case A3Cursor.Type.RESIZE_SE://FIXME

                    return PointerIcon.TYPE_TOP_LEFT_DIAGONAL_DOUBLE_ARROW;
                case A3Cursor.Type.RESIZE_NESW:

                case A3Cursor.Type.RESIZE_NE://FIXME
                case A3Cursor.Type.RESIZE_SW://FIXME

                    return PointerIcon.TYPE_TOP_RIGHT_DIAGONAL_DOUBLE_ARROW;
                case A3Cursor.Type.HAND:
                    return PointerIcon.TYPE_HAND;
                case A3Cursor.Type.MOVE:
                    return PointerIcon.TYPE_ALL_SCROLL;
                case A3Cursor.Type.GRAB:
                    return PointerIcon.TYPE_GRAB;
                case A3Cursor.Type.GRABBING:
                    return PointerIcon.TYPE_GRABBING;
                case A3Cursor.Type.HELP:
                    return PointerIcon.TYPE_HELP;
                case A3Cursor.Type.NO:
                    return PointerIcon.TYPE_NO_DROP;
                case A3Cursor.Type.ZOOM_IN:
                    return PointerIcon.TYPE_ZOOM_IN;
                case A3Cursor.Type.ZOOM_OUT:
                    return PointerIcon.TYPE_ZOOM_OUT;
                default:
                    return -1;
            }
        }
        else {
            return -1;
        }
    }

    public static int pointerIconType2CursorType(int type) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            switch (type) {
                case PointerIcon.TYPE_NULL:
                    return A3Cursor.Type.GONE;
                case PointerIcon.TYPE_ARROW:
                    return A3Cursor.Type.ARROW;
                case PointerIcon.TYPE_CROSSHAIR:
                    return A3Cursor.Type.CROSSHAIR;
                case PointerIcon.TYPE_TEXT:
                    return A3Cursor.Type.IBEAM;
                case PointerIcon.TYPE_WAIT:
                    return A3Cursor.Type.WAIT;
                case PointerIcon.TYPE_VERTICAL_DOUBLE_ARROW:
                    return A3Cursor.Type.RESIZE_NS;
                case PointerIcon.TYPE_HORIZONTAL_DOUBLE_ARROW:
                    return A3Cursor.Type.RESIZE_WE;
                case PointerIcon.TYPE_TOP_LEFT_DIAGONAL_DOUBLE_ARROW:
                    return A3Cursor.Type.RESIZE_NWSE;
                case PointerIcon.TYPE_TOP_RIGHT_DIAGONAL_DOUBLE_ARROW:
                    return A3Cursor.Type.RESIZE_NESW;
                case PointerIcon.TYPE_HAND:
                    return A3Cursor.Type.HAND;
                case PointerIcon.TYPE_ALL_SCROLL:
                    return A3Cursor.Type.MOVE;
                case PointerIcon.TYPE_GRAB:
                    return A3Cursor.Type.GRAB;
                case PointerIcon.TYPE_GRABBING:
                    return A3Cursor.Type.GRABBING;
                case PointerIcon.TYPE_HELP:
                    return A3Cursor.Type.HELP;
                case PointerIcon.TYPE_NO_DROP:
                    return A3Cursor.Type.NO;
                case PointerIcon.TYPE_ZOOM_IN:
                    return A3Cursor.Type.ZOOM_IN;
                case PointerIcon.TYPE_ZOOM_OUT:
                    return A3Cursor.Type.ZOOM_OUT;
                default:
                    return -1;
            }
        }
        else {
            return -1;
        }
    }

    public static boolean linesIntersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {
        /*
         * A = (x2-x1, y2-y1) B = (x3-x1, y3-y1) C = (x4-x1, y4-y1) D = (x4-x3,
         * y4-y3) = C-B E = (x1-x3, y1-y3) = -B F = (x2-x3, y2-y3) = A-B
         *
         * Result is ((AxB) * (AxC) <=0) and ((DxE) * (DxF) <= 0)
         *
         * DxE = (C-B)x(-B) = BxB-CxB = BxC DxF = (C-B)x(A-B) = CxA-CxB-BxA+BxB =
         * AxB+BxC-AxC
         */

        x2 -= x1; // A
        y2 -= y1;
        x3 -= x1; // B
        y3 -= y1;
        x4 -= x1; // C
        y4 -= y1;

        double AvB = x2 * y3 - x3 * y2;
        double AvC = x2 * y4 - x4 * y2;

        // Online
        if (AvB == 0.0 && AvC == 0.0) {
            if (x2 != 0.0) {
                return
                        (x4 * x3 <= 0.0) ||
                                ((x3 * x2 >= 0.0) &&
                                        (x2 > 0.0 ? x3 <= x2 || x4 <= x2 : x3 >= x2 || x4 >= x2));
            }
            if (y2 != 0.0) {
                return
                        (y4 * y3 <= 0.0) ||
                                ((y3 * y2 >= 0.0) &&
                                        (y2 > 0.0 ? y3 <= y2 || y4 <= y2 : y3 >= y2 || y4 >= y2));
            }
            return false;
        }

        double BvC = x3 * y4 - x4 * y3;

        return (AvB * AvC <= 0.0) && (BvC * (AvB + BvC - AvC) <= 0.0);
    }

    public static int bitmapConfig2ImageType(final Bitmap.Config config) {
        switch (config) {
            case ARGB_8888:
                return A3Image.Type.ARGB_8888;
            case RGB_565:
                return A3Image.Type.RGB_565;
            default:
                return -1;
        }
    }

    public static Bitmap.Config imageType2BitmapConfig(final int type) {
        switch (type) {
            case A3Image.Type.ARGB_8888:
                return Bitmap.Config.ARGB_8888;
            case A3Image.Type.RGB_565:
                return Bitmap.Config.RGB_565;
            default:
                return null;
        }
    }

}
